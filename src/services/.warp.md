# Service Layer Development Rules - EduDash Pro

## API Service Architecture Standards

### Service Organization
```
services/
├── auth/
│   ├── authService.ts          # Authentication logic
│   ├── roleService.ts          # Role-based access control
│   └── impersonationService.ts # Super-admin impersonation
├── ai/
│   ├── lessonGenerator.ts      # AI lesson creation
│   ├── gradingService.ts       # AI-powered grading
│   ├── chatService.ts          # AI chat interactions
│   └── usageTracker.ts         # AI usage monitoring
├── data/
│   ├── schoolService.ts        # School/tenant management
│   ├── userService.ts          # User management
│   ├── contentService.ts       # Lessons, homework content
│   └── analyticsService.ts     # Data analytics
├── media/
│   ├── uploadService.ts        # File uploads
│   ├── storageService.ts       # Storage management
│   └── processingService.ts    # Media processing
├── notifications/
│   ├── pushService.ts          # Push notifications
│   ├── emailService.ts         # Email notifications
│   └── realTimeService.ts      # Real-time updates
└── billing/
    ├── subscriptionService.ts  # Subscription management
    ├── paymentService.ts       # Payment processing
    └── usageService.ts         # Usage tracking
```

### Multi-Tenant Database Patterns

#### Supabase Client Configuration
```typescript
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';

// Regular client with RLS enforcement
export const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// Service role client for Super-Admin operations (bypasses RLS)
export const supabaseServiceClient = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
);
```

#### Tenant-Scoped Query Patterns
```typescript
// Always include school_id for tenant isolation
const getTenantData = async (schoolId: string, userId: string) => {
  const { data, error } = await supabase
    .from('lessons')
    .select('*')
    .eq('school_id', schoolId)
    .eq('created_by', userId)
    .order('created_at', { ascending: false });

  if (error) throw new ServiceError('Failed to fetch lessons', error);
  return data;
};

// Super-Admin queries bypass tenant isolation
const getAllSchoolsData = async () => {
  const { data, error } = await supabaseServiceClient
    .from('schools')
    .select(`
      *,
      users:users(count),
      subscriptions:subscriptions(*)
    `)
    .order('created_at', { ascending: false });

  if (error) throw new ServiceError('Failed to fetch schools', error);
  return data;
};
```

### Standard Service Response Pattern
```typescript
export interface ServiceResponse<T> {
  data?: T;
  error?: ServiceError;
  meta?: {
    requestId: string;
    timestamp: Date;
    cached?: boolean;
    aiUsage?: {
      tokens: number;
      cost: number;
    };
  };
}

export class ServiceError extends Error {
  constructor(
    public message: string,
    public originalError?: any,
    public code?: string,
    public statusCode?: number
  ) {
    super(message);
    this.name = 'ServiceError';
  }
}

// Standard error handler
export const handleServiceError = (
  error: unknown,
  context: string
): ServiceResponse<never> => {
  console.error(`Service error in ${context}:`, error);
  
  const serviceError = error instanceof ServiceError 
    ? error 
    : new ServiceError(
        error instanceof Error ? error.message : 'Unknown error',
        error,
        'SERVICE_ERROR',
        500
      );

  return {
    error: serviceError,
    meta: {
      requestId: crypto.randomUUID(),
      timestamp: new Date()
    }
  };
};
```

### AI Service Integration Patterns

#### Anthropic Claude Integration
```typescript
import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY!,
});

export interface LessonGenerationRequest {
  schoolId: string;
  teacherId: string;
  prompt: string;
  grade: string;
  subject: string;
  duration?: number;
  learningObjectives?: string[];
}

export const generateLesson = async (
  request: LessonGenerationRequest
): Promise<ServiceResponse<GeneratedLesson>> => {
  try {
    // Track AI usage for billing
    const startTime = Date.now();
    
    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 4000,
      temperature: 0.7,
      messages: [{
        role: "user",
        content: buildLessonPrompt(request)
      }],
      stream: false
    });

    const endTime = Date.now();
    const tokens = estimateTokenUsage(message.content[0].text);
    const cost = calculateAICost(tokens, 'claude-3-5-sonnet');

    // Log AI usage for billing and monitoring
    await logAIUsage({
      schoolId: request.schoolId,
      userId: request.teacherId,
      operation: 'lesson_generation',
      tokens,
      cost,
      duration: endTime - startTime
    });

    const lesson = parseLessonResponse(message.content[0].text);

    return {
      data: lesson,
      meta: {
        requestId: crypto.randomUUID(),
        timestamp: new Date(),
        aiUsage: { tokens, cost }
      }
    };
  } catch (error) {
    return handleServiceError(error, 'generateLesson');
  }
};
```

#### AI Usage Tracking
```typescript
interface AIUsageLog {
  schoolId: string;
  userId: string;
  operation: 'lesson_generation' | 'grading' | 'chat' | 'content_analysis';
  tokens: number;
  cost: number;
  duration: number;
  timestamp: Date;
}

export const logAIUsage = async (usage: AIUsageLog): Promise<void> => {
  try {
    await supabase
      .from('ai_usage_logs')
      .insert([{
        school_id: usage.schoolId,
        user_id: usage.userId,
        operation: usage.operation,
        tokens_used: usage.tokens,
        cost_usd: usage.cost,
        duration_ms: usage.duration,
        created_at: usage.timestamp.toISOString()
      }]);
  } catch (error) {
    console.error('Failed to log AI usage:', error);
    // Don't throw - logging shouldn't break the main operation
  }
};

// Check if school has remaining AI credits
export const checkAIQuota = async (
  schoolId: string
): Promise<{ hasQuota: boolean; remaining: number }> => {
  const { data: school } = await supabase
    .from('schools')
    .select('ai_credits_remaining, subscription_tier')
    .eq('id', schoolId)
    .single();

  if (!school) throw new ServiceError('School not found');

  return {
    hasQuota: school.ai_credits_remaining > 0,
    remaining: school.ai_credits_remaining
  };
};
```

### Authentication & Authorization Services

#### Role-Based Access Control
```typescript
export type UserRole = 'super_admin' | 'principal' | 'teacher' | 'parent';

export interface UserPermissions {
  canCreateSchool: boolean;
  canManageUsers: boolean;
  canAccessAnalytics: boolean;
  canUseAI: boolean;
  canImpersonate: boolean;
  canManageBilling: boolean;
}

export const getUserPermissions = (role: UserRole): UserPermissions => {
  const permissions: Record<UserRole, UserPermissions> = {
    super_admin: {
      canCreateSchool: true,
      canManageUsers: true,
      canAccessAnalytics: true,
      canUseAI: true,
      canImpersonate: true,
      canManageBilling: true,
    },
    principal: {
      canCreateSchool: false,
      canManageUsers: true, // Within their school
      canAccessAnalytics: true, // School-level only
      canUseAI: true,
      canImpersonate: false,
      canManageBilling: true, // School billing only
    },
    teacher: {
      canCreateSchool: false,
      canManageUsers: false,
      canAccessAnalytics: false, // Class-level only
      canUseAI: true,
      canImpersonate: false,
      canManageBilling: false,
    },
    parent: {
      canCreateSchool: false,
      canManageUsers: false,
      canAccessAnalytics: false, // Student progress only
      canUseAI: false,
      canImpersonate: false,
      canManageBilling: false,
    },
  };

  return permissions[role];
};
```

#### Super-Admin Impersonation
```typescript
export const impersonateUser = async (
  adminId: string,
  targetUserId: string
): Promise<ServiceResponse<{ sessionToken: string }>> => {
  try {
    // Verify admin has impersonation permissions
    const { data: admin } = await supabaseServiceClient
      .from('users')
      .select('role')
      .eq('id', adminId)
      .single();

    if (admin?.role !== 'super_admin') {
      throw new ServiceError('Insufficient permissions', null, 'FORBIDDEN', 403);
    }

    // Create impersonation session
    const impersonationToken = await createImpersonationSession(targetUserId);
    
    // Log the impersonation for audit trail
    await logAuditEvent({
      adminId,
      action: 'USER_IMPERSONATION',
      targetUserId,
      timestamp: new Date()
    });

    return {
      data: { sessionToken: impersonationToken },
      meta: {
        requestId: crypto.randomUUID(),
        timestamp: new Date()
      }
    };
  } catch (error) {
    return handleServiceError(error, 'impersonateUser');
  }
};
```

### File Upload & Media Services

#### Mobile-Optimized File Upload
```typescript
export interface FileUploadOptions {
  schoolId: string;
  userId: string;
  bucket: 'homework' | 'lessons' | 'profiles' | 'media';
  maxSize: number;
  allowedTypes: string[];
  generateThumbnail?: boolean;
  compressImage?: boolean; // For mobile optimization
}

export const uploadFile = async (
  file: File,
  options: FileUploadOptions
): Promise<ServiceResponse<{ url: string; path: string }>> => {
  try {
    // Validate file type and size
    if (!options.allowedTypes.includes(file.type)) {
      throw new ServiceError('Invalid file type', null, 'INVALID_FILE_TYPE', 400);
    }

    if (file.size > options.maxSize) {
      throw new ServiceError('File too large', null, 'FILE_TOO_LARGE', 400);
    }

    // Compress image if needed (mobile optimization)
    const processedFile = options.compressImage && file.type.startsWith('image/')
      ? await compressImage(file)
      : file;

    // Generate unique file path with tenant isolation
    const fileName = `${options.schoolId}/${options.userId}/${Date.now()}-${file.name}`;

    // Upload to Supabase Storage
    const { data, error } = await supabase.storage
      .from(options.bucket)
      .upload(fileName, processedFile);

    if (error) throw new ServiceError('Upload failed', error);

    // Get public URL
    const { data: { publicUrl } } = supabase.storage
      .from(options.bucket)
      .getPublicUrl(fileName);

    // Generate thumbnail if requested
    if (options.generateThumbnail && file.type.startsWith('image/')) {
      await generateThumbnail(fileName, options.bucket);
    }

    return {
      data: {
        url: publicUrl,
        path: fileName
      },
      meta: {
        requestId: crypto.randomUUID(),
        timestamp: new Date()
      }
    };
  } catch (error) {
    return handleServiceError(error, 'uploadFile');
  }
};
```

### Real-Time Services

#### Supabase Real-time Subscriptions
```typescript
export const subscribeToSchoolUpdates = (
  schoolId: string,
  callback: (payload: any) => void
): (() => void) => {
  const channel = supabase
    .channel(`school:${schoolId}`)
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'lessons',
        filter: `school_id=eq.${schoolId}`
      },
      callback
    )
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'submissions',
        filter: `school_id=eq.${schoolId}`
      },
      callback
    )
    .subscribe();

  // Return cleanup function
  return () => {
    supabase.removeChannel(channel);
  };
};
```

### Performance & Caching

#### Service-Level Caching
```typescript
const cache = new Map<string, { data: any; expiry: number }>();

export const withCache = <T>(
  key: string,
  ttlMs: number,
  fetcher: () => Promise<T>
): Promise<T> => {
  return new Promise(async (resolve, reject) => {
    try {
      // Check cache first
      const cached = cache.get(key);
      if (cached && Date.now() < cached.expiry) {
        resolve(cached.data);
        return;
      }

      // Fetch fresh data
      const data = await fetcher();
      
      // Cache the result
      cache.set(key, {
        data,
        expiry: Date.now() + ttlMs
      });

      resolve(data);
    } catch (error) {
      reject(error);
    }
  });
};

// Usage example
export const getCachedSchoolData = (schoolId: string) =>
  withCache(
    `school:${schoolId}`,
    5 * 60 * 1000, // 5 minutes
    () => fetchSchoolData(schoolId)
  );
```

### Error Handling & Monitoring

#### Service Monitoring
```typescript
export const withMonitoring = <T extends any[], R>(
  serviceName: string,
  fn: (...args: T) => Promise<R>
) => {
  return async (...args: T): Promise<R> => {
    const startTime = Date.now();
    
    try {
      const result = await fn(...args);
      
      // Log successful operation
      console.log(`Service ${serviceName} completed in ${Date.now() - startTime}ms`);
      
      return result;
    } catch (error) {
      // Log error with context
      console.error(`Service ${serviceName} failed after ${Date.now() - startTime}ms:`, error);
      
      // Re-throw to maintain error handling chain
      throw error;
    }
  };
};
```

Remember: 
- Always include `school_id` in tenant-scoped operations
- Use service role client only for Super-Admin cross-tenant operations  
- Implement proper error handling and logging
- Consider mobile network conditions in service design
- Cache appropriate data to improve mobile performance
- Track AI usage for billing and quota management
- Include comprehensive audit logging for security
